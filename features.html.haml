---
layout: default
title: Feature Tour
body_class: features
---
#content
  .feature 
    %img{ :src=>'http://design.jboss.org/arquillian/logo/ui/images/success/arquillian_ui_success_256px.png', :width=>200, :height=>200 }
    %h2 Write Real Tests
    %p Mocks can be tactical, but more often than not they are used to make code work outside of a real environment. Arquillian let's you leave the mocks behind and write real tests. That's because Arquillian brings your test to the target runtime, thus giving you meaningful feedback and insight about how the code really works. In fact, it's even better than the real thing, because you can replicate any number of real world scenarios in the test sandbox.
  .feature 
    %img{ :src=>'http://design.jboss.org/arquillian/logo/ui/images/success/arquillian_ui_success_256px.png', :width=>200, :height=>200  }
    %h2 IDE Friendly
    %p The learning curve for getting started with Arquillian is minimized by the fact that it integrates with what you already know. Are you using JUnit for your unit tests? Then you would benefit from reusing your knowledge of JUnit when doing integration testing as well. Or maybe TestNG? Arquillian allows you to make that choice.
    %p Fix the bug and rerun the test! Arquilian tests are designed for quick turnaround. That's accomplished by cutting out all the voodoo typically associated with integration tests so that the test can be launched from existing IDE and build test plugins. The ShrinkWrap-defined test archive picks up pre-complied resources and hands them off to Arquillian to stream to the server. Integration testing has never been so lean. 
  .feature 
    %img{ :src=>'http://design.jboss.org/arquillian/logo/ui/images/success/arquillian_ui_success_256px.png', :width=>200, :height=>200  }
    %h2 Test Enrichment
    %p Your application and tests can share the same programming model, regardless of technology stack. For example, Arquillian can inject the deployed Contexts and Dependency Injection (CDI) beans, Enterprise JavaBeans (EJB) components and other Java EE resources directly to your tests. Arquillian can also extend that programming model to provide access to container APIs and implicit objects from test frameworks such as JSFUnit and Selenium.
  .feature 
    %img{ :src=>'http://design.jboss.org/arquillian/logo/ui/images/success/arquillian_ui_success_256px.png', :width=>200, :height=>200  }
    %h2 Microdeployments
    %p Most test suites are a mess, but it's not your fault. Test frameworks carelessly use whatever classes and resources are on the classpath of the test, making isolation of the test scenario difficult and turning the test suite into a Frankenstein. Not Arquillian. Arquillian leverages ShrinkWrap to explicitly define the classes and resources applicable to the current test, termed a microdeployment.
    %p Arquillian gives you fine-grained control over what your a testing. Whether you want to focus on a handful of classes, or you want to move files around virtually, ShrinkWrap gives you the control you need. You can focus on the area of the code under test and, if necessary, easily substitute alternative components to support the test scenario. You can even tests the impossible (scenarios).
    %p Microdeployments are typically much smaller than the full application, so the test archive deploys faster, which means you get a faster test-code-test development cycle.
  .feature 
    %img{ :src=>'http://design.jboss.org/arquillian/logo/ui/images/success/arquillian_ui_success_256px.png', :width=>200, :height=>200  }
    %h2 Debug the Server
    %p Arquillian brings you server-side debugging like never before. Typically, you have to package the application, deploy it to the server, connect the debugger and interact with the UI in order to hit the breakpoint. Now you can just drop a breakpoint in the test or the application code and debug the test. Bang, you hit the breakpoint inside the server from the comfort of your IDE. Prepare for an eye opening experience!
  .feature 
    %img{ :src=>'http://design.jboss.org/arquillian/logo/ui/images/success/arquillian_ui_success_256px.png', :width=>200, :height=>200  }
    %h2 Drive the Browser
    %p Arquillian is just as relevant for client testing as it is for server-side testing. Arquillian Drone abstracts away all the tedious setup of the Selenium Server, letting you skip right to testing with the browser driver API and deployment URL in hand. Arquillian even blurs the line between client and server-side testing by letting you instrument the deployment while testing from the client, which is most apparent in the JSFUnit integration.
  .feature 
    %img{ :src=>'http://design.jboss.org/arquillian/logo/ui/images/success/arquillian_ui_success_256px.png', :width=>200, :height=>200  }
    %h2 Environments
    %p You name the container, Arquillian can manage it. (If not, why not write an adapter?) Having the choice of multiple containers serves several different needs. You may want to use an embedded container in development, then switch to a standalone container for the continuous integration job. The standalone container may be in one of several staging environments in which the tests must be run. Perhaps you want to test on different compliant containers to ensure application portability. Nearing real world concerns, you may need to interact with several containers in the same test to validate distributed behavior. All of these scenarios are possible with Arquillian's multiple container and multiple deployment capabilities.
  .feature 
    %img{ :src=>'http://design.jboss.org/arquillian/logo/ui/images/success/arquillian_ui_success_256px.png', :width=>200, :height=>200  }
    %h2 Extensible Platform
    %p There's no limit to what you can test using Arquillian. If you're looking for an integration that's not implemented today, Arquillian provides an extensible enterprise testing platform into which you can integrate that next great testing tool or strategy.
